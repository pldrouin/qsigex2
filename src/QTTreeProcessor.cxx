#define DEBUG
#define DEBUG2

#include "QTTreeProcessor.h"

#include "debugger.h"

ClassImp(QTTreeProcessor)

void QTTreeProcessor::AddParam(const char *parname, Int_t index)
{
  fParamsNames.Add(parname,index);
  fParams.Add(0.0,index);
}

void QTTreeProcessor::AddProc(const char *name, const char *title, Int_t index)
{
  fProcs.RedimList(fProcs.Count()+1,index);
  fProcs[index].SetNameTitle(name,title);
}

void QTTreeProcessor::AddProc(const char *name, const char *title, void (*proc)(Double_t**, Double_t**, Double_t**),const char *procname, Int_t index)
{
  AddProc(name,title,index);
  fProcs[index].SetProc(proc,procname);
}

void QTTreeProcessor::AddProc(const char *name, const char *title, const char *procname, Int_t index)
{
  AddProc(name,title,index);
  fProcs[index].SetProc(procname);
}

void QTTreeProcessor::AddProc(const char *name, const char *title, void *proc, const char *procname, Int_t index)
{
  AddProc(name,title,index);
  fProcs[index].SetProc(proc,procname);
}

Int_t QTTreeProcessor::Analyze()
{
  Int_t i,j;
  QNamedProc *proc;
  QList<TString> params; //Parameters
  QList<QList<TString> > itrees;  //Existing trees that are used as inputs
  QList<QList<TString> > otrees;  //Trees that are generated
  QList<QList< QList<TString> > > allitrees, allotrees;  //trees information for all processes
  QList<QList<TString> > ibranches; //Existing branches that are read
  QList<QList<TString> > obranches; //Branches that are generated
  QList<TString> iobufs; //buffers
  TString sbuf;
  QList<TString> donbuf;       //Decoded object name buffer
  TDirectory *curdir=gDirectory;

  Int_t nprocs=fProcs.Count();
  Int_t ninputs, noutputs, nparams;
  Int_t iidx, oidx;

  allitrees.RedimList(nprocs);
  allotrees.RedimList(nprocs);

  //Loop over the processes
  for(i=0; i<nprocs; i++) {
    proc=&(fProcs[i]);
    ninputs=proc->GetNInputs();
    noutputs=proc->GetNOutputs();
    nparams=proc->GetNParams();
    allitrees[i].RedimList(ninputs);
    allotrees[i].RedimList(noutputs);

    //Loop over the parameters for the current process
    for(j=0; j<nparams; j++) {
      sbuf=proc->GetParam(j).GetName();

      //If the current parameter is not listed in the list of parameters
      if(fParamsNames.FindFirst(sbuf) == -1) {
	fprintf(stderr,"QTTreeProcessor::Analyze(): Error with process '%s': Parameter '%s' does not exist\n",proc->GetName(),sbuf.Data());
	return -1;
      }
    }

    //Loop over the inputs for the current process
    for(j=0; j<ninputs; j++) {
      sbuf=proc->GetInput(j);

      //If the input is from a tree
      if(sbuf.Length()) {
	donbuf=QSigExUtils::DecodeObjName(sbuf);

	if(!donbuf.Count()) {
	  fprintf(stderr,"QTTreeProcessor::Analyze(): Error: Invalid input object name: '%s'\n",sbuf.Data());
	  return -1;
	}

	allitrees[i][j]=donbuf;

	oidx=otrees.FindFirst(donbuf);
	donbuf.Clear();

	//If this tree has not been generated by a previous process
	if(oidx == -1) {
	  iidx=itrees.AddUnique(donbuf);

	  //If the tree is not already listed in the list of existing trees
	  if(iidx == -1) {
	    //Add the name of the required branch
	    ibranches.RedimList(itrees.Count());
	    ibranches[itrees.Count()-1].Add(proc->GetInput(j).GetName());

	    //Else if the tree is already listed
	  } else {
	    //Ensure the required branch is in the list
	    ibranches[iidx].AddUnique(proc->GetInput(j).GetName());
	  }

	  //Else if the tree has been generated by a previous process and that the branch has not been
	  //listed in the list of generated branches
	} else if(obranches[oidx].FindFirst(proc->GetInput(j).GetName()) == -1) {
	  fprintf(stderr,"QTTreeProcessor::Analyze(): Error with process '%s': Input branch '%s' for tree '%s' was not generated by a previous process\n",proc->GetName(),proc->GetInput(j).GetName(),(otrees[oidx][1]+"/"+otrees[oidx][0]).Data());
	  return -1;

	}

	//Else if the input is from a buffer in memory and the buffer has not been listed as an output for a previous process
      } else if(iobufs.FindFirst(proc->GetInput(j).GetName()) == -1) {
	fprintf(stderr,"QTTreeProcessor: Analyze(): Error with process '%s': Input buffer '%s' was not generated by a previous process\n",proc->GetName(),proc->GetInput(j).GetName());
	return -1;
      }
    }

    //Loop over the outputs for the current process
    for(j=0; j<noutputs; j++) {
      sbuf=proc->GetOutput(j);

      //If the output is in a tree
      if(sbuf.Length()) {
	donbuf=QSigExUtils::DecodeObjName(sbuf);

	if(!donbuf.Count()) {
	  fprintf(stderr,"QTTreeProcessor::Analyze(): Error: Invalid output object name: '%s'\n",sbuf.Data());
	  return -1;
	}

	allotrees[i][j]=donbuf;

	if(itrees.FindFirst(donbuf) != -1) {
	  fprintf(stderr,"QTTreeProcessor: Analyze(): Error with process '%s': Branch '%s' for tree '%s' cannot be overwritten\n",proc->GetName(),proc->GetInput(j).GetName(),(donbuf[1]+"/"+donbuf[0]).Data());
	  return -1;
	}

	oidx=otrees.AddUnique(donbuf);

	//If this tree has not been generated by a previous process
	if(oidx == -1) {
	  //Add the name of the output branch
	  obranches.RedimList(otrees.Count());
	  obranches[otrees.Count()-1].Add(proc->GetOutput(j).GetName());

	  //Else if the tree is already listed
	} else {
	  //Ensure the output branch is in the list
	  obranches[oidx].AddUnique(proc->GetOutput(j).GetName());
	}

	//Else if the output is to a buffer in memory
      } else {
	//Ensure the output memory buffer is in the list
	iobufs.AddUnique(proc->GetOutput(j).GetName());
      }
    }
  }

  return 0;
}

void QTTreeProcessor::DelParam(const char *paramname)
{
  Int_t i;
  if((i=FindParamIndex(paramname))!=-1) DelParam(i);
}

void QTTreeProcessor::DelProc(const char *procname)
{
  Int_t i;
  if((i=FindProcIndex(procname))!=-1) fProcs.Del(i);
}

Int_t QTTreeProcessor::FindParamIndex(const char *paramname) const
{
  for(Int_t i=0; i<fParams.Count(); i++){
    if(!strcmp(fParamsNames[i],paramname)) return i;
  }
  return -1;
}

Int_t QTTreeProcessor::FindProcIndex(const char *procname) const
{
  for(Int_t i=0; i<fProcs.Count(); i++){
    if(!strcmp(fProcs[i].GetName(),procname)) return i;
  }
  return -1;
}

QNamedProc& QTTreeProcessor::GetProc(const char *procname) const
{
  Int_t i;
  if((i=FindProcIndex(procname))!=-1){
    return fProcs[i];
  }
  fprintf(stderr,"QTTreeProcessor::GetProc: Procedure '%s' does not exist\n",procname);
  throw 1;
  return fProcs[0];
}

void QTTreeProcessor::SetParam(const char *paramname, Double_t value)
{
  Int_t i;
  if((i=FindParamIndex(paramname))!=-1) SetParam(i,value);
}

void QTTreeProcessor::SetParams(Double_t *params)
{
  memcpy(fParams.GetArray(),params,fParams.Count()*sizeof(Double_t));
}

#include "debugger.h"
